{"version":3,"sources":["node_modules/browser-pack/_prelude.js","jquery-scrolltofixed.js"],"names":[],"mappings":"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","file":"jquery-scrolltofixed-min.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n * ScrollToFixed\n * https://github.com/bigspotteddog/ScrollToFixed\n *\n * Copyright (c) 2011 Joseph Cava-Lynch\n * MIT license\n */\n(function($) {\n    $.isScrollToFixed = function(el) {\n        return !!$(el).data('ScrollToFixed');\n    };\n\n    $.ScrollToFixed = function(el, options) {\n        // To avoid scope issues, use 'base' instead of 'this' to reference this\n        // class from internal events and functions.\n        var base = this;\n\n        // Access to jQuery and DOM versions of element.\n        base.$el = $(el);\n        base.el = el;\n\n        // Add a reverse reference to the DOM object.\n        base.$el.data('ScrollToFixed', base);\n\n        // A flag so we know if the scroll has been reset.\n        var isReset = false;\n\n        // The element that was given to us to fix if scrolled above the top of\n        // the page.\n        var target = base.$el;\n\n        var position;\n        var originalPosition;\n        var originalFloat;\n        var originalOffsetTop;\n        var originalZIndex;\n\n        // The offset top of the element when resetScroll was called. This is\n        // used to determine if we have scrolled past the top of the element.\n        var offsetTop = 0;\n\n        // The offset left of the element when resetScroll was called. This is\n        // used to move the element left or right relative to the horizontal\n        // scroll.\n        var offsetLeft = 0;\n        var originalOffsetLeft = -1;\n\n        // This last offset used to move the element horizontally. This is used\n        // to determine if we need to move the element because we would not want\n        // to do that for no reason.\n        var lastOffsetLeft = -1;\n\n        // This is the element used to fill the void left by the target element\n        // when it goes fixed; otherwise, everything below it moves up the page.\n        var spacer = null;\n\n        var spacerClass;\n\n        var className;\n\n        // Capture the original offsets for the target element. This needs to be\n        // called whenever the page size changes or when the page is first\n        // scrolled. For some reason, calling this before the page is first\n        // scrolled causes the element to become fixed too late.\n        function resetScroll() {\n            // Set the element to it original positioning.\n            target.trigger('preUnfixed.ScrollToFixed');\n            setUnfixed();\n            target.trigger('unfixed.ScrollToFixed');\n\n            // Reset the last offset used to determine if the page has moved\n            // horizontally.\n            lastOffsetLeft = -1;\n\n            // Capture the offset top of the target element.\n            offsetTop = target.offset().top;\n\n            // Capture the offset left of the target element.\n            offsetLeft = target.offset().left;\n\n            // If the offsets option is on, alter the left offset.\n            if (base.options.offsets) {\n                offsetLeft += (target.offset().left - target.position().left);\n            }\n\n            if (originalOffsetLeft == -1) {\n                originalOffsetLeft = offsetLeft;\n            }\n\n            position = target.css('position');\n\n            // Set that this has been called at least once.\n            isReset = true;\n\n            if (base.options.bottom != -1) {\n                target.trigger('preFixed.ScrollToFixed');\n                setFixed();\n                target.trigger('fixed.ScrollToFixed');\n            }\n        }\n\n        function getLimit() {\n            var limit = base.options.limit;\n            if (!limit) return 0;\n\n            if (typeof(limit) === 'function') {\n                return limit.apply(target);\n            }\n            return limit;\n        }\n\n        // Returns whether the target element is fixed or not.\n        function isFixed() {\n            return position === 'fixed';\n        }\n\n        // Returns whether the target element is absolute or not.\n        function isAbsolute() {\n            return position === 'absolute';\n        }\n\n        function isUnfixed() {\n            return !(isFixed() || isAbsolute());\n        }\n\n        // Sets the target element to fixed. Also, sets the spacer to fill the\n        // void left by the target element.\n        function setFixed() {\n            // Only fix the target element and the spacer if we need to.\n            if (!isFixed()) {\n                //get REAL dimensions (decimal fix)\n                //Ref. http://stackoverflow.com/questions/3603065/how-to-make-jquery-to-not-round-value-returned-by-width\n                var dimensions = target[0].getBoundingClientRect();\n\n                // Set the spacer to fill the height and width of the target\n                // element, then display it.\n                spacer.css({\n                    'display' : target.css('display'),\n                    'width' : dimensions.width,\n                    'height' : dimensions.height,\n                    'float' : target.css('float')\n                });\n\n                // Set the target element to fixed and set its width so it does\n                // not fill the rest of the page horizontally. Also, set its top\n                // to the margin top specified in the options.\n\n                var cssOptions={\n                    'z-index' : base.options.zIndex,\n                    'position' : 'fixed',\n                    'top' : base.options.bottom == -1?getMarginTop():'',\n                    'bottom' : base.options.bottom == -1?'':base.options.bottom,\n                    'margin-left' : '0px'\n                }\n                if (!base.options.dontSetWidth){ cssOptions['width']=target.css('width'); };\n\n                target.css(cssOptions);\n\n                target.addClass(base.options.baseClassName);\n\n                if (base.options.className) {\n                    target.addClass(base.options.className);\n                }\n\n                position = 'fixed';\n            }\n        }\n\n        function setAbsolute() {\n\n            var top = getLimit();\n            var left = offsetLeft;\n\n            if (base.options.removeOffsets) {\n                left = '';\n                top = top - offsetTop;\n            }\n\n            var cssOptions={\n              'position' : 'absolute',\n              'top' : top,\n              'left' : left,\n              'margin-left' : '0px',\n              'bottom' : ''\n            }\n            if (!base.options.dontSetWidth){ cssOptions['width']=target.css('width'); };\n\n            target.css(cssOptions);\n\n            position = 'absolute';\n        }\n\n        // Sets the target element back to unfixed. Also, hides the spacer.\n        function setUnfixed() {\n            // Only unfix the target element and the spacer if we need to.\n            if (!isUnfixed()) {\n                lastOffsetLeft = -1;\n\n                // Hide the spacer now that the target element will fill the\n                // space.\n                spacer.css('display', 'none');\n\n                // Remove the style attributes that were added to the target.\n                // This will reverse the target back to the its original style.\n                target.css({\n                    'z-index' : originalZIndex,\n                    'width' : '',\n                    'position' : originalPosition,\n                    'left' : '',\n                    'top' : originalOffsetTop,\n                    'margin-left' : ''\n                });\n\n                target.removeClass(base.options.baseClassName);\n\n                if (base.options.className) {\n                    target.removeClass(base.options.className);\n                }\n\n                position = null;\n            }\n        }\n\n        // Moves the target element left or right relative to the horizontal\n        // scroll position.\n        function setLeft(x) {\n            // Only if the scroll is not what it was last time we did this.\n            if (x != lastOffsetLeft) {\n                // Move the target element horizontally relative to its original\n                // horizontal position.\n                target.css('left', offsetLeft - x);\n\n                // Hold the last horizontal position set.\n                lastOffsetLeft = x;\n            }\n        }\n\n        function getMarginTop() {\n            var marginTop = base.options.marginTop;\n            if (!marginTop) return 0;\n\n            if (typeof(marginTop) === 'function') {\n                return marginTop.apply(target);\n            }\n            return marginTop;\n        }\n\n        // Checks to see if we need to do something based on new scroll position\n        // of the page.\n        function checkScroll() {\n            if (!$.isScrollToFixed(target) || target.is(':hidden')) return;\n            var wasReset = isReset;\n            var wasUnfixed = isUnfixed();\n\n            // If resetScroll has not yet been called, call it. This only\n            // happens once.\n            if (!isReset) {\n                resetScroll();\n            } else if (isUnfixed()) {\n                // if the offset has changed since the last scroll,\n                // we need to get it again.\n\n                // Capture the offset top of the target element.\n                offsetTop = target.offset().top;\n\n                // Capture the offset left of the target element.\n                offsetLeft = target.offset().left;\n            }\n\n            // Grab the current horizontal scroll position.\n            var x = $(window).scrollLeft();\n\n            // Grab the current vertical scroll position.\n            var y = $(window).scrollTop();\n\n            // Get the limit, if there is one.\n            var limit = getLimit();\n\n            // If the vertical scroll position, plus the optional margin, would\n            // put the target element at the specified limit, set the target\n            // element to absolute.\n            if (base.options.minWidth && $(window).width() < base.options.minWidth) {\n                if (!isUnfixed() || !wasReset) {\n                    postPosition();\n                    target.trigger('preUnfixed.ScrollToFixed');\n                    setUnfixed();\n                    target.trigger('unfixed.ScrollToFixed');\n                }\n            } else if (base.options.maxWidth && $(window).width() > base.options.maxWidth) {\n                if (!isUnfixed() || !wasReset) {\n                    postPosition();\n                    target.trigger('preUnfixed.ScrollToFixed');\n                    setUnfixed();\n                    target.trigger('unfixed.ScrollToFixed');\n                }\n            } else if (base.options.bottom == -1) {\n                // If the vertical scroll position, plus the optional margin, would\n                // put the target element at the specified limit, set the target\n                // element to absolute.\n                if (limit > 0 && y >= limit - getMarginTop()) {\n                    if (!wasUnfixed && (!isAbsolute() || !wasReset)) {\n                        postPosition();\n                        target.trigger('preAbsolute.ScrollToFixed');\n                        setAbsolute();\n                        target.trigger('unfixed.ScrollToFixed');\n                    }\n                // If the vertical scroll position, plus the optional margin, would\n                // put the target element above the top of the page, set the target\n                // element to fixed.\n                } else if (y >= offsetTop - getMarginTop()) {\n                    if (!isFixed() || !wasReset) {\n                        postPosition();\n                        target.trigger('preFixed.ScrollToFixed');\n\n                        // Set the target element to fixed.\n                        setFixed();\n\n                        // Reset the last offset left because we just went fixed.\n                        lastOffsetLeft = -1;\n\n                        target.trigger('fixed.ScrollToFixed');\n                    }\n                    // If the page has been scrolled horizontally as well, move the\n                    // target element accordingly.\n                    setLeft(x);\n                } else {\n                    // Set the target element to unfixed, placing it where it was\n                    // before.\n                    if (!isUnfixed() || !wasReset) {\n                        postPosition();\n                        target.trigger('preUnfixed.ScrollToFixed');\n                        setUnfixed();\n                        target.trigger('unfixed.ScrollToFixed');\n                    }\n                }\n            } else {\n                if (limit > 0) {\n                    if (y + $(window).height() - target.outerHeight(true) >= limit - (getMarginTop() || -getBottom())) {\n                        if (isFixed()) {\n                            postPosition();\n                            target.trigger('preUnfixed.ScrollToFixed');\n\n                            if (originalPosition === 'absolute') {\n                                setAbsolute();\n                            } else {\n                                setUnfixed();\n                            }\n\n                            target.trigger('unfixed.ScrollToFixed');\n                        }\n                    } else {\n                        if (!isFixed()) {\n                            postPosition();\n                            target.trigger('preFixed.ScrollToFixed');\n                            setFixed();\n                        }\n                        setLeft(x);\n                        target.trigger('fixed.ScrollToFixed');\n                    }\n                } else {\n                    setLeft(x);\n                }\n            }\n        }\n\n        function getBottom() {\n            if (!base.options.bottom) return 0;\n            return base.options.bottom;\n        }\n\n        function postPosition() {\n            var position = target.css('position');\n\n            if (position == 'absolute') {\n                target.trigger('postAbsolute.ScrollToFixed');\n            } else if (position == 'fixed') {\n                target.trigger('postFixed.ScrollToFixed');\n            } else {\n                target.trigger('postUnfixed.ScrollToFixed');\n            }\n        }\n\n        var windowResize = function(event) {\n            // Check if the element is visible before updating it's position, which\n            // improves behavior with responsive designs where this element is hidden.\n            if(target.is(':visible')) {\n                isReset = false;\n                checkScroll();\n            } else {\n              // Ensure the spacer is hidden\n              setUnfixed();\n            }\n        }\n\n        var windowScroll = function(event) {\n            (!!window.requestAnimationFrame) ? requestAnimationFrame(checkScroll) : checkScroll();\n        }\n\n        // From: http://kangax.github.com/cft/#IS_POSITION_FIXED_SUPPORTED\n        var isPositionFixedSupported = function() {\n            var container = document.body;\n\n            if (document.createElement && container && container.appendChild && container.removeChild) {\n                var el = document.createElement('div');\n\n                if (!el.getBoundingClientRect) return null;\n\n                el.innerHTML = 'x';\n                el.style.cssText = 'position:fixed;top:100px;';\n                container.appendChild(el);\n\n                var originalHeight = container.style.height,\n                originalScrollTop = container.scrollTop;\n\n                container.style.height = '3000px';\n                container.scrollTop = 500;\n\n                var elementTop = el.getBoundingClientRect().top;\n                container.style.height = originalHeight;\n\n                var isSupported = (elementTop === 100);\n                container.removeChild(el);\n                container.scrollTop = originalScrollTop;\n\n                return isSupported;\n            }\n\n            return null;\n        }\n\n        var preventDefault = function(e) {\n            e = e || window.event;\n            if (e.preventDefault) {\n                e.preventDefault();\n            }\n            e.returnValue = false;\n        }\n\n        // Initializes this plugin. Captures the options passed in, turns this\n        // off for devices that do not support fixed position, adds the spacer,\n        // and binds to the window scroll and resize events.\n        base.init = function() {\n            // Capture the options for this plugin.\n            base.options = $.extend({}, $.ScrollToFixed.defaultOptions, options);\n\n            originalZIndex = target.css('z-index')\n\n            // Turn off this functionality for devices that do not support it.\n            // if (!(base.options && base.options.dontCheckForPositionFixedSupport)) {\n            //     var fixedSupported = isPositionFixedSupported();\n            //     if (!fixedSupported) return;\n            // }\n\n            // Put the target element on top of everything that could be below\n            // it. This reduces flicker when the target element is transitioning\n            // to fixed.\n            base.$el.css('z-index', base.options.zIndex);\n\n            // Create a spacer element to fill the void left by the target\n            // element when it goes fixed.\n            spacer = $('<div />');\n\n            position = target.css('position');\n            originalPosition = target.css('position');\n            originalFloat = target.css('float');\n            originalOffsetTop = target.css('top');\n\n            // Place the spacer right after the target element.\n            if (isUnfixed()) base.$el.after(spacer);\n\n            // Reset the target element offsets when the window is resized, then\n            // check to see if we need to fix or unfix the target element.\n            $(window).bind('resize.ScrollToFixed', windowResize);\n\n            // When the window scrolls, check to see if we need to fix or unfix\n            // the target element.\n            $(window).bind('scroll.ScrollToFixed', windowScroll);\n\n            // For touch devices, call checkScroll directlly rather than\n            // rAF wrapped windowScroll to animate the element\n            if ('ontouchmove' in window) {\n              $(window).bind('touchmove.ScrollToFixed', checkScroll);\n            }\n\n            if (base.options.preFixed) {\n                target.bind('preFixed.ScrollToFixed', base.options.preFixed);\n            }\n            if (base.options.postFixed) {\n                target.bind('postFixed.ScrollToFixed', base.options.postFixed);\n            }\n            if (base.options.preUnfixed) {\n                target.bind('preUnfixed.ScrollToFixed', base.options.preUnfixed);\n            }\n            if (base.options.postUnfixed) {\n                target.bind('postUnfixed.ScrollToFixed', base.options.postUnfixed);\n            }\n            if (base.options.preAbsolute) {\n                target.bind('preAbsolute.ScrollToFixed', base.options.preAbsolute);\n            }\n            if (base.options.postAbsolute) {\n                target.bind('postAbsolute.ScrollToFixed', base.options.postAbsolute);\n            }\n            if (base.options.fixed) {\n                target.bind('fixed.ScrollToFixed', base.options.fixed);\n            }\n            if (base.options.unfixed) {\n                target.bind('unfixed.ScrollToFixed', base.options.unfixed);\n            }\n\n            if (base.options.spacerClass) {\n                spacer.addClass(base.options.spacerClass);\n            }\n\n            target.bind('resize.ScrollToFixed', function() {\n                spacer.height(target.height());\n            });\n\n            target.bind('scroll.ScrollToFixed', function() {\n                target.trigger('preUnfixed.ScrollToFixed');\n                setUnfixed();\n                target.trigger('unfixed.ScrollToFixed');\n                checkScroll();\n            });\n\n            target.bind('detach.ScrollToFixed', function(ev) {\n                preventDefault(ev);\n\n                target.trigger('preUnfixed.ScrollToFixed');\n                setUnfixed();\n                target.trigger('unfixed.ScrollToFixed');\n\n                $(window).unbind('resize.ScrollToFixed', windowResize);\n                $(window).unbind('scroll.ScrollToFixed', windowScroll);\n\n                target.unbind('.ScrollToFixed');\n\n                //remove spacer from dom\n                spacer.remove();\n\n                base.$el.removeData('ScrollToFixed');\n            });\n\n            // Reset everything.\n            windowResize();\n        };\n\n        // Initialize the plugin.\n        base.init();\n    };\n\n    // Sets the option defaults.\n    $.ScrollToFixed.defaultOptions = {\n        marginTop : 0,\n        limit : 0,\n        bottom : -1,\n        zIndex : 1000,\n        baseClassName: 'scroll-to-fixed-fixed'\n    };\n\n    // Returns enhanced elements that will fix to the top of the page when the\n    // page is scrolled.\n    $.fn.scrollToFixed = function(options) {\n        return this.each(function() {\n            (new $.ScrollToFixed(this, options));\n        });\n    };\n})(jQuery);\n"]}